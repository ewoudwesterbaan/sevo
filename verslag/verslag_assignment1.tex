\documentclass[a4paper]{article}

\usepackage{xcolor}
\usepackage{fancyheadings}
\usepackage{listings}
\usepackage{graphicx}


\newcommand{\todo}[1]{\textcolor{red}{[#1]}}
\lhead{Open Universiteit}
\chead{IM0202, Software evolution}
\rhead{Assignment 1}

\begin{document}
\pagestyle{fancy}

\section*{Studentgegevens}
\begin{description}
	\item [Cursuscode] IM0202
	\item [Naam] \todo{invullen}
	\item [Studentnummer] \todo{invullen}
	\item [Naam] Martin de Boer
	\item [Studentnummer] 837372832
\end{description}

\section*{Samenwerking}
Nadat Ewoud een git repository had aangemaakt voor het rascal
project, zijn we beide begonnen aan een eigen module. De modules
zijn parallel aan elkaar ontwikkeld, zodat er redelijk
zelfstandig kon worden gewerkt. In grote lijnen heeft Ewoud de
modules \texttt{metrics::Volume.rsc} en
\texttt{metrics::Duplicates.rsc} voor zijn rekening genomen, en
Martin de modules \texttt{metrics::UnitSize.rsc} en
\texttt{metrics::Complexity.rsc}.

De module \texttt{metrics::Volume.rsc} berekent het aantal lines
of code (LOC). \texttt{metrics::UnitSize.rsc} doet hetzelfde
voor de units (methodes en constructoren) in het project. De
module \texttt{metrics::Duplicates.rsc} zoekt naar dubbele code
in het project. En de module \texttt{metrics::Complexity.rsc},
tenslotte, bepaalt per unit (methode/constructor) de complexity
measure.

Bepaalde code leende zich voor hergebruik, en daarvoor is in
samenspraak een module \texttt{utils::Utils} in het leven
geroepen, waaraan beide auteurs hebben gewerkt.

Martin heeft tijdens het ontwikkelen van de modules een eerste
opzet gemaakt voor het unittesten van de modules. Het
inhoudelijk schrijven van de testcode is op dezelfde wijze
verdeeld als de modules zelf: beide auteurs hebben de testcode
voor hun eigen modules geschreven. Voor het testen is er wat
intensiever samengewerkt, ook omdat daarbij aanvankelijk wat
technische probleempjes optraden.

\section{Aannames}
\subsection{Duplicaten}
In onze oplossing vergelijken we de content van methodes en constructoren met elkaar, maar dit gebeurt in één richting. Als methode A wordt vergeleken met methode B, wordt methode B niet meer vergeleken met methode A. Stel dat het aantal opeenvolgende regels dat identiek is, 6 is. Dan is de duplicatiewaarde over de oplossing dus 6 / 12, dus 50\%. Als we dan drie methodes gebruiken, dan wordt methode A met methode B vergeleken, methode A met methode C én methode B en methode C. Het aantal duplicate regels is dan 18, wat gelijk is aan het totaal van aantal regels. In figuur \ref{fig:DuplicatenDetectie} hebben we dit doorgetrokken. op de x as staan het aantal methodes dat dezelfde code bevat. De blauwe lijn geeft het totaal aantal regels code in de oplossing aan, en de rode lijn het aantal gedetecteerde duplicate regels. Het is dus mogelijk dat het duplicatiepercentage boven de 100\% komt.
\begin{figure}[htbp]
\caption{Oplopen van detectieregels bij meerdere methodes}
\centering
\includegraphics[width=0.8 \textwidth]{DuplicatenDetectie.PNG}
\label{fig:DuplicatenDetectie}
\end{figure}
Wij hebben dit dus anders aangepakt. 

\subsection{Unitsize versus volume}
We zien een verschil in de dom van de unitsize ten opzicht an het volume. Wij beschouwen het volume als alle regels code in een java file, zonder commentaar en zonder de lege ruimtes. \texttt{Import} statements en field definitions beschouwen wij als ook onderdeel van het volume. De som van de regels code daarentegen, is de som van de inhoud van de methodes en contructoren. Omdat de complexiteit en duplicaten berekend worden over de inhoud van de methodes en constructoren, gebruiken wij deze metriek om het duplicaat en de complexiteit percentages te berekenen.


\subsection{Lines of code}
Dit is van belang voor de metrieken volume en unitsize. Beiden
maken gebruik van regels code die geen commentaar zijn. Omdat
dit een gemeenschappelijke logica is, is deze gedefinieerd in de
\texttt{utils::Utils} module.
Regels code worden nu beschouwd als alle niet lege regels minus
de commentaar regels.

We beschouwen een regel commentaar als deze begint met
\lstinline{//}. Voor blokcommentaar is de eerste gedacht om zo
ook regeles die starten met \lstinline{/*}, \lstinline{*} of
\lstinline{*/} te beschouwen als commentaar. Dit gaat alleen
niet helemaal op. Als voorbeeld nemen we Listing
\ref{lst:asterixcmt}. Dit is valide java code en regel 2 begint
met een \lstinline{*}.

\begin{lstlisting}[caption={* als commentaar
beschouwen},label={lst:asterixcmt},escapechar=|, frame = single]
int i = 1
* 2;
\end{lstlisting}

We zouden kunnen zeggen dat de volume het aantal LOC van de
methodes is. Maar dan missen we de velden en de Instance
Initialization Blocks (wat geen constructors zijn).

\subsection{Volume}
De volume metric maakt volledig gebruik van de Utils module. De
hoeveelheid regels code per java bestand wordt bepaald. Om de
regels code te tellen, verwijderen we het blockcommentaar en

\subsection{Complexity}
De complexiteitsmaat heeft betrekking op het aantal paden die in
een unit (methode of constructor) kan worden bewandeld. Dit zegt
iets over de testbaarheid van zo'n unit. We gaan er vanuit dat
de standaard complexiteitsmaat de waarde 1 heeft, en dat er voor
een aantal taaconstructies reden is om deze met 1 te verhogen.
Deze taalconstructies blijken duidelijk uit de onderstaande
code:

\begin{lstlisting}[caption={Taalsconstructies die de
complexiteit verhogen},label={lst:complexity},escapechar=|,
frame = single]
int complexity = 1;
visit(stat) {
  case \case(_) : complexity += 1;
  case \do(_, _) : complexity += 1;
  case \if(_, _) : complexity += 1;
  case \catch(_,_): complexity += 1;
  case \while(_, _) : complexity += 1;
  case \if(_, _, _) : complexity += 1;
  case \for(_, _, _) : complexity += 1;
  case infix(_,"&&",_) : complexity += 1;
  case infix(_,"||",_) : complexity += 1;    
  case \for(_, _, _, _) : complexity += 1;
  case \foreach(_, _, _) : complexity += 1;
  case \conditional(_,_,_): complexity += 1;
}
\end{lstlisting}

De \texttt{if}-constructies spreken voor zich: de conditie kan
waar zijn of niet. Er zijn dus twee mogelijkheden, waarmee het
aantal mogelijke paden met 1 wordt uitgebreid. Ditzelfde geldt
voor de \texttt{conditional} in Java (feitelijk een alternatieve
manier van het schrijven van een if-constructie, bijv.:
\texttt{b == true ? x : y;}). De \texttt{do}, \texttt{while},
\texttt{for}, en \texttt{foreach} be\"invloeden de complexiteit
op een vergelijkbare manier. In het \texttt{switch}-statement,
is iedere \texttt{case} te beschouwen als een
\texttt{if}-statement, en dus verhogen we voor iedere
\texttt{case} de complexiteitsmaat met 1.
De \texttt{default}-tak voegt wel een extra stap, maar geen
extra pad aan de sequentie van statements toe, en heeft dus geen
invoed op de complexiteitsmaat.
Het optreden van een exception kan worden afgehandeld in een
\texttt{catch}-blok. Ieder \texttt{catch}-blok voegt een nieuw
pad aan de control-flow van het programma toe, zodat ook dit de
complexiteit verhoogd.
Tenslotte is er de infix-notatie (AND, of OR-variant) die
invloed heeft op het aantal paden. We verhogen hiervoor de de
complexiteitsmaat wederom met 1, omdat het al dan niet
\texttt{true} zijn van de linker-conditie bepaald of de tweede
conditie wordt bepaald.

\subsection{Duplicaten}
Gedurende het project zijn we overgestapt naar een andere
signature van methode locaties. In het begin van het project was
een locatie bijvoorbeeld
\lstinline{|java+method:///DuplicationTestClass/duplicationTestLastPartEquals_ExpectTrue()|},
later is dit veranderd naar
\texttt{|project://DuplicationTest/src/DuplicationTestClass.java|(1085,260,<42,49>,<51,2>)}.
Dit had invloed op de content die met elkaar vergeleken werd.
Deze locaties zijn te krijgen door de \texttt{getUnits()} aan te
roepen in de module \texttt{utils::Utils}. Met de eerste
locatie, was de content die eruit gehaald werd inclusief de
method (of constructor) signature (bijvoorbeeld: \texttt{public
int getNumber()}). Op de tweede manier begint de content die
opgehaald worden met de accolade (\texttt{\{}) achter de method
signature. Met de regressie testen van de duplicaten, blijkt dus
dat het aantal gelijke regels overal met 1 was toegenomen. De vraag die nu opspeelt is: moeten we de methode signatures ook zien als code dat vergeleken moet worden. In het artikel wordt aangegeven dat duplicatie gaat over code in de code-blocks. We beschouwen de method signature daar niet onder. De accolades waarmee de methode start en eind moeten dus ook verwijderd worden bij het schoonmaken (trimmen van de content en het verwijderen van commentaar).

\section{Betrouwbaarheid}
De betrouwbaaheid en de juistheid van de oplossing kunnen we waarborgen door het gebruik van unittests. We hebben meerdere `dummy'-projecten gemaakt die dienen als referentieproject bij het draaien van deze tests. Door dat we zelf deze projecten maken, welke klein en overzichtelijk zijn, kunnen we vrij specifiek meten, testen en de juistheid valideren van de opgeleverde code.

\section{Interpretatie}


\end{document}
