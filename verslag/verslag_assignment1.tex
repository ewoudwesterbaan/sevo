\documentclass[a4paper]{article}

\usepackage{xcolor}
\usepackage{fancyheadings}
\usepackage{listings}


\newcommand{\todo}[1]{\textcolor{red}{[#1]}}
\lhead{Open Universiteit}
\chead{IM0202, Software evolution}
\rhead{Assignment 1}

\begin{document}
\pagestyle{fancy}

\section*{Studentgegevens}
\begin{description}
	\item [Cursuscode] IM0202
	\item [Naam] \todo{invullen}
	\item [Studentnummer] \todo{invullen}
	\item [Naam] Martin de Boer
	\item [Studentnummer] 837372832
\end{description}

\section*{Aanpak}
Nadat Ewoud een git repository had aangemaakt voor het rascal
project, zijn we beide begonnen aan een eigen module. De modules
zijn parallel aan elkaar ontwikkeld, zodat er redelijk
zelfstandig kon worden gewerkt. In grote lijnen heeft Ewoud de
modules \texttt{metrics::Volume.rsc} en
\texttt{metrics::Duplicates.rsc} voor zijn rekening genomen, en
Martin de modules \texttt{metrics::UnitSize.rsc} en
\texttt{metrics::Complexity.rsc}.

De module \texttt{metrics::Volume.rsc} berekent het aantal lines
of code (LOC). \texttt{metrics::UnitSize.rsc} doet hetzelfde
voor de units (methodes en constructoren) in het project. De
module \texttt{metrics::Duplicates.rsc} zoekt naar dubbele code
in het project. En de module \texttt{metrics::Complexity.rsc},
tenslotte, bepaalt per unit (methode/constructor) de complexity
measure.

Bepaalde code leende zich voor hergebruik, en daarvoor is in
samenspraak een module \texttt{utils::Utils} in het leven
geroepen, waaraan beide auteurs hebben gewerkt.

Martin heeft tijdens het ontwikkelen van de modules een eerste
opzet gemaakt voor het unittesten van de modules. Het
inhoudelijk schrijven van de testcode is op dezelfde wijze
verdeeld als de modules zelf: beide auteurs hebben de testcode
voor hun eigen modules geschreven. Voor het testen is er wat
intensiever samengewerkt, ook omdat daarbij aanvankelijk wat
technische probleempjes optraden.

\todo{Geef aan hoe jullie de opdracht hebben aangepakt en wie
wat heeft gedaan, maximaal 1 A-4. Geef expliciet aandacht aan de
volgorde van activiteiten}



\section{Keuzen}
\subsection{Lines of code}
Dit is van belang voor de metrieken volume en unitsize. Beiden
maken gebruik van regels code die geen commentaar zijn. Omdat
dit een gemeenschappelijke logica is, is deze gedefinieerd in de
\texttt{utils::Utils} module.
Regels code worden nu beschouwd als alle niet lege regels minus
de commentaar regels.

We beschouwen een regel commentaar als deze begint met
\lstinline{//}. Voor blokcommentaar is de eerste gedacht om zo
ook regeles die starten met \lstinline{/*}, \lstinline{*} of
\lstinline{*/} te beschouwen als commentaar. Dit gaat alleen
niet helemaal op. Als voorbeeld nemen we Listing
\ref{lst:asterixcmt}. Dit is valide java code en regel 2 begint
met een \lstinline{*}.

\begin{lstlisting}[caption={* als commentaar
beschouwen},label={lst:asterixcmt},escapechar=|, frame = single]
int i = 1
* 2;
\end{lstlisting}

We zouden kunnen zeggen dat de volume het aantal LOC van de
methodes is. Maar dan missen we de velden en de Instance
Initialization Blocks (wat geen constructors zijn).

\subsection{Volume}
De volume metric maakt volledig gebruik van de Utils module. De
hoeveelheid regels code per java bestand wordt bepaald. Om de
regels code te tellen, verwijderen we het blockcoimmentaar en

\subsection{Complexity}
De complexiteitsmaat heeft betrekking op het aantal paden die in
een unit (methode of constructor) kan worden bewandeld. Dit zegt
iets over de testbaarheid van zo'n unit. We gaan er vanuit dat
de standaard complexiteitsmaat de waarde 1 heeft, en dat er voor
een aantal taaconstructies reden is om deze met 1 te verhogen.
Deze taalconstructies blijken duidelijk uit de onderstaande
code:

\begin{lstlisting}[caption={Taalsconstructies die de
complexiteit verhogen},label={lst:complexity},escapechar=|,
frame = single]
int complexity = 1;
visit(stat) {
  case \case(_) : complexity += 1;
  case \do(_, _) : complexity += 1;
  case \if(_, _) : complexity += 1;
  case \catch(_,_): complexity += 1;
  case \while(_, _) : complexity += 1;
  case \if(_, _, _) : complexity += 1;
  case \for(_, _, _) : complexity += 1;
  case infix(_,"&&",_) : complexity += 1;
  case infix(_,"||",_) : complexity += 1;    
  case \for(_, _, _, _) : complexity += 1;
  case \foreach(_, _, _) : complexity += 1;
  case \conditional(_,_,_): complexity += 1;
}
\end{lstlisting}

De \texttt{if}-constructies spreken voor zich: de conditie kan
waar zijn of niet. Er zijn dus twee mogelijkheden, waarmee het
aantal mogelijke paden met 1 wordt uitgebreid. Ditzelfde geldt
voor de \texttt{conditional} in Java (feitelijk een alternatieve
manier van het schrijven van een if-constructie, bijv.:
\texttt{b == true ? x : y;}). De \texttt{do}, \texttt{while},
\texttt{for}, en \texttt{foreach} be\"invloeden de complexiteit
op een vergelijkbare manier. In het \texttt{switch}-statement,
is iedere \texttt{case} te beschouwen als een
\texttt{if}-statement, en dus verhogen we voor iedere
\texttt{case} de complexiteitsmaat met 1.
De \texttt{default}-tak voegt wel een extra stap, maar geen
extra pad aan de sequentie van statements toe, en heeft dus geen
invoed op de complexiteitsmaat.
Het optreden van een exception kan worden afgehandeld in een
\texttt{catch}-blok. Ieder \texttt{catch}-blok voegt een nieuw
pad aan de control-flow van het programma toe, zodat ook dit de
complexiteit verhoogd.
Tenslotte is er de infix-notatie (AND, of OR-variant) die
invloed heeft op het aantal paden. We verhogen hiervoor de de
complexiteitsmaat wederom met 1, omdat het al dan niet
\texttt{true} zijn van de linker-conditie bepaald of de tweede
conditie wordt bepaald.

\subsection{Duplicaten}
Gedurende het project zijn we overgestapt naar een andere
signature van methode locaties. In het begin van het project was
een locatie bijvoorbeeld
\lstinline{|java+method:///DuplicationTestClass/duplicationTestLastPartEquals_ExpectTrue()|},
later is dit veranderd naar
\texttt{|project://DuplicationTest/src/DuplicationTestClass.java|(1085,260,<42,49>,<51,2>)}.
Dit had invloed op de content die met elkaar vergeleken werd.
Deze locaties zijn te krijgen door de \texttt{getUnits()} aan te
roepen in de module \texttt{utils::Utils}. Met de eerste
locatie, was de content die eruit gehaald werd inclusief de
method (of constructor) signature (bijvoorbeeld: \texttt{public
int getNumber()}). Op de tweede manier begint de content die
opgehaald worden met de accolade (\texttt{\{}) achter de method
signature. Met de regressie testen van de duplicaten, blijkt dus
dat het aantal gelijke regels overal met 1 was toegenomen. De vraag die nu opspeelt is: moeten we de methode signatures ook zien als code dat vergeleken moet worden. In het artikel wordt aangegeven dat duplicatie gaat over code in de code-blocks. We beschouwen de method signature daar niet onder. De accolades waarmee de methode start en eind moeten dus ook verwijderd worden bij het schoonmaken (trimmen van de content en het verwijderen van commentaar).

\section{Juistheid}

\section{Interpretatie}

\end{document}
